<%= turbo_stream_from "statements" %>

<style>
  @keyframes glow-border {
    0% {
      outline: 2px solid rgba(66, 165, 245, 0.8);
      outline-offset: 0px;
    }
    50% {
      outline: 2px solid rgba(66, 165, 245, 1);
      outline-offset: 3px;
    }
    100% {
      outline: 2px solid rgba(66, 165, 245, 0.8);
      outline-offset: 0px;
    }
  }
  
  .glow-button {
    animation: glow-border 1.5s ease-in-out infinite;
    position: relative;
  }
  
  .glow-button:hover {
    animation-play-state: paused;
    outline: 2px solid rgba(66, 165, 245, 1);
    outline-offset: 2px;
  }

  /* ACE Editor cursor styling - sharp vertical line */
  .ace_cursor {
    border-left: 2px solid !important;
    border-radius: 0 !important;
  }
</style>

<div id=<%= dom_id(query, 'statement-box') %> class='' style="position: relative; border-radius: 10px;">
  <% 
    # Handle different contexts - job vs regular view rendering
    form_url = if local_assigns[:form_url]
      local_assigns[:form_url]
    elsif defined?(sage) && sage.respond_to?(:run_queries_path)
      sage.run_queries_path
    elsif respond_to?(:run_queries_path)
      run_queries_path
    else
      # Fallback to engine route
      Sage::Engine.routes.url_helpers.run_queries_path
    end
  %>
  <%= form_with url: form_url, method: :post, data: { turbo_frame: dom_id(query, 'results') } do |f| %>
    <%= f.hidden_field :statement, id: 'query_statement' %>
    <%= f.hidden_field :query_id, value: query.id %>
    <%= f.hidden_field :data_source, value: query.data_source || Blazer.data_sources.keys.first %>
    <div id="editor-container" style="position: relative;">
      <div id="editor" style="height: 225px;" data-initial-content="<%= local_assigns[:statement] || query.statement %>"><%= local_assigns[:statement] || query.statement %></div>
    </div>
  <% end %>
</div>

<%= javascript_tag nonce: true do %>
  function formatSQL() {
    if (!window.aceEditor) return;
    
    const sql = window.aceEditor.getValue();
    const formatted = formatSQLString(sql);
    window.aceEditor.setValue(formatted, -1);
  }
  
  function formatSQLString(sql) {
    // SQL keywords that should be uppercase and on new lines
    const mainKeywords = ['SELECT', 'FROM', 'WHERE', 'GROUP BY', 'HAVING', 'ORDER BY', 'LIMIT', 'OFFSET', 
                         'INSERT', 'UPDATE', 'DELETE', 'CREATE', 'ALTER', 'DROP', 'TRUNCATE',
                         'UNION', 'UNION ALL', 'INTERSECT', 'EXCEPT', 'WITH'];
    
    const joinKeywords = ['LEFT JOIN', 'RIGHT JOIN', 'INNER JOIN', 'FULL OUTER JOIN', 'CROSS JOIN', 'JOIN', 'ON'];
    
    const otherKeywords = ['AND', 'OR', 'NOT', 'IN', 'EXISTS', 'BETWEEN', 'LIKE', 'IS', 'NULL', 
                          'CASE', 'WHEN', 'THEN', 'ELSE', 'END', 'AS', 'DISTINCT', 'ALL',
                          'ASC', 'DESC', 'CAST', 'COUNT', 'SUM', 'AVG', 'MIN', 'MAX',
                          'COALESCE', 'NULLIF', 'DATE_TRUNC', 'EXTRACT', 'SUBSTRING',
                          'CONCAT', 'LENGTH', 'LOWER', 'UPPER', 'TRIM', 'REPLACE'];
    
    // Preserve string literals, comments, and JSON operators
    const preservedStrings = [];
    let preservedIndex = 0;
    
    // Replace strings with placeholders
    sql = sql.replace(/'([^']|'')*'/g, (match) => {
      preservedStrings.push(match);
      return `__PRESERVED_STRING_${preservedIndex++}__`;
    });
    
    // Replace comments with placeholders  
    sql = sql.replace(/--[^\n]*/g, (match) => {
      preservedStrings.push(match);
      return `__PRESERVED_STRING_${preservedIndex++}__`;
    });
    
    sql = sql.replace(/\/\*[\s\S]*?\*\//g, (match) => {
      preservedStrings.push(match);
      return `__PRESERVED_STRING_${preservedIndex++}__`;
    });
    
    // Preserve JSON operators and comparison operators EARLY before any other processing
    sql = sql.replace(/->>|->|#>>|#>|@>|<@|>=|<=|<>|!=|\?\?|\?&|\?/g, (match) => {
      preservedStrings.push(match);
      return `__PRESERVED_STRING_${preservedIndex++}__`;
    });
    
    // Remove extra whitespace and normalize spaces
    sql = sql.replace(/\s+/g, ' ').trim();
    
    // Format main keywords - add newline before them
    mainKeywords.forEach(keyword => {
      const regex = new RegExp('\\b' + keyword + '\\b', 'gi');
      sql = sql.replace(regex, '\n' + keyword);
    });
    
    // Format JOIN keywords - add newline before them
    joinKeywords.forEach(keyword => {
      const regex = new RegExp('\\b' + keyword + '\\b', 'gi');
      sql = sql.replace(regex, '\n' + keyword);
    });
    
    // Make all SQL keywords uppercase (but not the preserved strings)
    [...mainKeywords, ...joinKeywords, ...otherKeywords].forEach(keyword => {
      const regex = new RegExp('\\b' + keyword + '\\b', 'gi');
      sql = sql.replace(regex, keyword);
    });
    
    // Format commas in SELECT list - add newline and indent after comma
    sql = sql.replace(/SELECT\s+(.*?)(?=\nFROM|\nWHERE|\nGROUP|\nHAVING|\nORDER|\nLIMIT|$)/gs, (match, selectList) => {
      // Only format if there are multiple items
      if (selectList.includes(',')) {
        selectList = selectList.replace(/,\s*/g, ',\n    ');
        return 'SELECT\n    ' + selectList.trim();
      }
      return 'SELECT ' + selectList.trim();
    });
    
    // Format AND/OR in WHERE clause - put on new line with indent
    sql = sql.replace(/\n(WHERE|HAVING)\s+(.*?)(?=\n(?:GROUP|ORDER|LIMIT|FROM|SELECT|$))/gs, (match, keyword, condition) => {
      condition = condition.replace(/\s+(AND|OR)\s+/gi, '\n  $1 ');
      return '\n' + keyword + ' ' + condition;
    });
    
    // Add indentation for subqueries
    sql = sql.replace(/\((\s*SELECT[\s\S]*?)\)/g, (match, subquery) => {
      const indentedSubquery = subquery.split('\n').map(line => '  ' + line).join('\n');
      return '(\n' + indentedSubquery + '\n)';
    });
    
    // Clean up multiple consecutive newlines
    sql = sql.replace(/\n\s*\n/g, '\n');
    
    // Restore preserved strings
    preservedStrings.forEach((str, index) => {
      sql = sql.replace(`__PRESERVED_STRING_${index}__`, str);
    });
    
    // Remove leading newline if present
    sql = sql.replace(/^\n+/, '');
    
    // Ensure consistent spacing around basic operators (complex operators already preserved)
    sql = sql.replace(/\s*=\s*/g, ' = ');
    sql = sql.replace(/\s*<\s*/g, ' < ');
    sql = sql.replace(/\s*>\s*/g, ' > ');
    
    // Final fix: repair any broken operators that slipped through
    sql = sql.replace(/>\s*=/g, '>=');
    sql = sql.replace(/<\s*=/g, '<='); 
    sql = sql.replace(/@\s*>/g, '@>');
    sql = sql.replace(/<\s*>/g, '<>');
    sql = sql.replace(/!\s*=/g, '!=');
    sql = sql.replace(/-\s*>/g, '->');
    sql = sql.replace(/-\s*>>/g, '->>');
    sql = sql.replace(/#\s*>/g, '#>');
    sql = sql.replace(/#\s*>>/g, '#>>');
    sql = sql.replace(/<\s*@/g, '<@');
    sql = sql.replace(/\?\s*\?/g, '??');
    sql = sql.replace(/\?\s*&/g, '?&');
    
    return sql;
  }
  
  function initializeEditor() {
  // Destroy existing editor if it exists
  if (window.aceEditor) {
    window.aceEditor.destroy();
  }
  
  var editor = ace.edit("editor")
  window.aceEditor = editor;
  editor.setTheme("ace/theme/twilight")
  editor.getSession().setMode("ace/mode/sql")
  editor.setOptions({
  enableBasicAutocompletion: false,
  enableSnippets: false,
  enableLiveAutocompletion: false,
  highlightActiveLine: false,
  fontSize: 12,
  minLines: 10,
  scrollPastEnd: 0.25
  })
  editor.renderer.setShowGutter(true)
  editor.renderer.setPrintMarginColumn(false)
  editor.setShowPrintMargin(false)
  editor.renderer.setPadding(10)
  editor.getSession().setUseWrapMode(true)
  
  // Ensure proper scrolling with bottom margin for buttons
  editor.renderer.setScrollMargin(0, 0, 60, 0)  // top, right, bottom, left margins
  editor.setAutoScrollEditorIntoView(true)
  
  // Force scrollbar to always be visible for consistent layout
  editor.setOption("vScrollBarAlwaysVisible", true)
  
  // Add bottom padding to content area to ensure last line is fully visible
  editor.renderer.setPadding(10, 10, 60, 10)  // top, right, bottom, left padding

  // Update all hidden fields when editor content changes
  editor.getSession().on("change", function () {
  const value = editor.getValue()
  $("#query_statement").val(value)  // For statement_box run form
  $("#query_statement_form").val(value)  // For main form
  $("#run_query_statement").val(value)  // For new_form run button
  })

  // Set initial value from data attribute or current content
  const editorDiv = document.getElementById("editor")
  let initialContent = editorDiv.getAttribute("data-initial-content") || editor.getValue()

  // Decode HTML entities that ERB escapes in the attribute
  // This handles &quot;, &#39;, &#10; (newlines), etc.
  if (initialContent && editorDiv.hasAttribute("data-initial-content")) {
    const textarea = document.createElement('textarea');
    textarea.innerHTML = initialContent;
    initialContent = textarea.value;
  }

  if (initialContent && initialContent !== editor.getValue()) {
    editor.setValue(initialContent, -1) // -1 moves cursor to start
  }
  
  const initialValue = editor.getValue()
  $("#query_statement").val(initialValue)
  $("#query_statement_form").val(initialValue)
  $("#run_query_statement").val(initialValue)
  editor.focus()

  // Add top padding to ace_scroller and gutter to keep them aligned
  const aceScroller = document.querySelector('.ace_scroller');
  const aceGutter = document.querySelector('.ace_gutter');

  if (aceScroller) {
  aceScroller.style.paddingTop = '10px';
  }
  if (aceGutter) {
  aceGutter.style.paddingTop = '10px';
  }
  }

  // Initialize on page load
  document.addEventListener('turbo:load', initializeEditor);
  
  // Initialize when this partial is replaced via Turbo Stream
  document.addEventListener('turbo:frame-load', initializeEditor);
  
  // Also initialize immediately if the DOM is already loaded
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeEditor);
  } else {
    initializeEditor();
  }
<% end %>
